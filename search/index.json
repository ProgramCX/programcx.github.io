[{"content":"Java 实现文件下载 使用HttpClient下载 阻塞方式下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 import java.io.IOException; import java.net.URI; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpClient; import java.nio.file.Paths; import java.nio.file.Path; public class Main { public static void main(String[] args) { downloadAFile(\u0026#34;https://pc-package.wpscdn.cn/wps/download/W.P.S.20.2735.exe\u0026#34;, \u0026#34;W.P.S.20.2735.exe\u0026#34;); } public static void downloadAFile(String url, String fileName) { HttpClient client = HttpClient.newHttpClient(); //创建一个HttpRequest请求 HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build(); Path filePath = Paths.get(fileName); try { //发送Http请求 HttpResponse\u0026lt;Path\u0026gt; response = client.send(request, HttpResponse.BodyHandlers.ofFile(filePath)); //判断是否成功下载 if (response.statusCode() == 200) { System.out.printf(\u0026#34;文件%s已经成功保存!\u0026#34;, fileName); } } catch (IOException | InterruptedException e) { throw new RuntimeException(e); } } } 在上述代码中，实现了一个名为downloadAFile()函数。使用 HttpClient.send() 方法发送Http请求并将响应体写入文件，并获得HttpResponse\u0026lt;Path\u0026gt;类型的response对象，使用该对象获得请求的状态码statusCode。\n异步方式下载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import java.io.IOException; import java.net.URI; import java.net.http.HttpRequest; import java.net.http.HttpResponse; import java.net.http.HttpClient; import java.nio.file.Paths; import java.nio.file.Path; import java.util.Scanner; public class Main { public static void main(String[] args) { downloadAFile(\u0026#34;https://pc-package.wpscdn.cn/wps/download/W.P.S.20.2735.exe\u0026#34;, \u0026#34;W.P.S.20.2735.exe\u0026#34;); System.out.println(\u0026#34;下载已经开始，按回车键结束...\u0026#34;); Scanner scanner = new Scanner(System.in); scanner.nextLine(); } public static void downloadAFile(String url, String fileName) { HttpClient client = HttpClient.newHttpClient(); //创建一个HttpRequest请求 HttpRequest request = HttpRequest.newBuilder(URI.create(url)).build(); Path filePath = Paths.get(fileName); //异步下载 client.sendAsync(request, HttpResponse.BodyHandlers.ofFile(filePath)).thenAccept(Main::downloadCallBack).exceptionally(e -\u0026gt; { System.out.println(\u0026#34;下载失败！\u0026#34; + e.getMessage()); return null; }); } private static void downloadCallBack(HttpResponse\u0026lt;Path\u0026gt; pathHttpResponse) { if (pathHttpResponse.statusCode() == 200) { System.out.println(\u0026#34;下载成功！文件已经保存至：\u0026#34; + pathHttpResponse.body()); } else { System.out.printf(\u0026#34;下载失败！状态码为%d。\\n\u0026#34;, pathHttpResponse.statusCode()); } } } 这里使用client.sendAsync()异步下载文件，thenAccept()来指定下载完成时的回调函数，exceptionally()来处理异常。注意，由于这里是异步下载的，不能使用try{}catch{}来处理异常，异常不能被捕获。\n使用OKHttp下载 导入OkHttp依赖 在pom.xml的\u0026lt;dependencies\u0026gt;\u0026lt;/dependencies\u0026gt;中添加以下代码：\n1 2 3 4 5 6 \u0026lt;!-- https://mvnrepository.com/artifact/com.squareup.okhttp3/okhttp --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.squareup.okhttp3\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;okhttp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; OKHttp获取文本文件 Download.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 package org.example; import okhttp3.*; import java.io.IOException; public class Download{ public final OkHttpClient client = new OkHttpClient(); public void run() throws IOException { Request request = new Request.Builder().url(\u0026#34;http://www.baidu.com\u0026#34;).build(); try(Response response = client.newCall(request).execute()){ if (response.body() != null) { System.out.println(response.body().string()); } }catch (Exception e){ System.out.println(e.getMessage()); } } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 package org.example; import java.io.IOException; public class Main { public static void main(String[] args) { Download download = new Download(); try{ download.run(); } catch (IOException e) { throw new RuntimeException(e); } } } OKHttp异步请求 Download.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 package org.example; import okhttp3.*; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.Objects; public class Download { private final String url; private final String fileName; private final String filePath; private final OkHttpClient client = new OkHttpClient(); public Download(String url, String fileName, String filePath) { this.url = url; this.fileName = fileName; this.filePath = filePath; } public void run() { Request request = new Request.Builder().url(url).build(); Call call = client.newCall(request); call.enqueue(new Callback() { @Override public void onFailure(Call call, IOException e) { e.printStackTrace(); } @Override //响应时的回调函数 public void onResponse(Call call, Response response) throws IOException { if (!response.isSuccessful()) { throw new IOException(\u0026#34;Unexpected code \u0026#34; + response); } try (InputStream inputStream = Objects.requireNonNull(response.body()).byteStream(); //从响应体获取字节流 FileOutputStream outputStream = new FileOutputStream(new File(filePath, fileName))) { //创建文件输出流 byte[] buffer = new byte[2048]; //创建缓存区，大小为2048KB int len; //用于还剩下多少字节没有被读取 while ((len = inputStream.read(buffer)) != -1) { //还没有被读取完 outputStream.write(buffer, 0, len); //将缓冲区数据写入文件 } System.out.printf(\u0026#34;文件%s已下载至%s%n\u0026#34;, fileName, filePath); } catch (IOException e) { e.printStackTrace(); } } }); } } Main.java\n1 2 3 4 5 6 7 8 9 10 11 package org.example; public class Main { public static void main(String[] args) { String url = \u0026#34;https://down-tencent.huorong.cn/sysdiag-all-x64-6.0.4.0-2024.11.16.1.exe\u0026#34;; String filename = \u0026#34;sysdiag-all-x64-6.0.4.0-2024.11.16.1.exe\u0026#34;; Download download = new Download(url, filename, \u0026#34;D:/\u0026#34;); download.run(); } } 上述代码中，使用Request.Builder().url(url).build()创建一个Request对象，使用Call类的call对象发起Http Get请求，使用enqueue()方法处理响应和错误。 在处理响应时，首先将response.body()响应体通过byteStream()方法转化为字节流，然后于FileInputStream一起使用写入文件。\nOKHttp同步请求 无需使用call.enqueue()方法，最后使用断言assertThat(response.code(), equalTo(200));判断状态码是否等于200即可。\n自定义请求头 1 Request request = new Request.Builder().url(url).addHeader(\u0026#34;Content-Length\u0026#34;,\u0026#34;application/x-msdownload\u0026#34;).build(); 允许重定向 1 private final OkHttpClient client = new OkHttpClient().newBuilder().followRedirects(true).build(); 超时设置 1 private final OkHttpClient client = new OkHttpClient().newBuilder().readTimeout(3, TimeUnit.SECONDS).build(); 取消请求 可以使用Call.cancel()终止请求。\n","date":"2024-11-16T00:00:00Z","image":"https://programcx.github.io/p/java-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java-%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/","title":"Java 实现文件下载"},{"content":"Vue 3 报错Uncaught TypeError:xxx.component is not a function 记录学习Vue 3过程中踩的坑\n一、错误代码 有以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const vueWatcher = { methods: { click(index) { if (index == 0) { alert(\u0026#34;外层\u0026#34;); } else if (index == 1) { alert(\u0026#34;中层\u0026#34;); } else if (index == 2) { alert(\u0026#34;内层\u0026#34;); } }, KeyDownCtrl() { alert(\u0026#34;Ctrl Pressed\u0026#34;); } } } const app = Vue.createApp(vueWatcher).mount(\u0026#34;#vue-watcher\u0026#34;); const alertComponent = { data() { return { msg: \u0026#34;警告\u0026#34;, } }, methods: { click() { alert(this.msg); } }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } app.component(\u0026#34;alert-component\u0026#34;, alertComponent); 我们是想要给 app对象添加一个标准的Vue组件alert-component，但是浏览器报错Uncaught TypeError:app.component is not a function。\n二、分析原因 其实这是一个添加子组件顺序的问题。上述错误代码中，先创建一个名为app的Vue对象，接着挂载到vue-watcher上，最后添加子组件alert-componet。 这种顺序是错误的，正确的顺序应该是：\n创建一个名为app的Vue对象； 1 const app = Vue.createApp(vueWatcher); 添加子组件alert-componet； 1 app.component(\u0026#34;alert-component\u0026#34;, alertComponent); 挂载到vue-watcher上。 1 app.mount(\u0026#34;#vue-watcher\u0026#34;); 三、正确代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 const vueWatcher = { methods: { click(index) { if (index == 0) { alert(\u0026#34;外层\u0026#34;); } else if (index == 1) { alert(\u0026#34;中层\u0026#34;); } else if (index == 2) { alert(\u0026#34;内层\u0026#34;); } }, KeyDownCtrl() { alert(\u0026#34;Ctrl Pressed\u0026#34;); } } } const app = Vue.createApp(vueWatcher); const alertComponent = { data() { return { msg: \u0026#34;警告\u0026#34;, } }, methods: { click() { alert(this.msg); } }, template: \u0026#39;\u0026lt;div\u0026gt;\u0026lt;button @click=\u0026#34;click\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt;\u0026#39; } app.component(\u0026#34;my\u0026#34;, alertComponent); app.mount(\u0026#34;#vue-watcher\u0026#34;); 欢迎指正错误！\n","date":"2024-10-15T00:00:00Z","image":"https://programcx.github.io/p/uncaught-typeerrorxxx.component-is-not-a-function/vue.svg","permalink":"https://programcx.github.io/p/uncaught-typeerrorxxx.component-is-not-a-function/","title":"Uncaught TypeError:xxx.component is not a function"},{"content":"Qt 5.15 connect() 函数的一个大坑 有以下代码：\n1 2 3 4 5 connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); 以上代码将ui-\u0026gt;styleComboBox的QComboBox::currentTextChanged信号连接至lambda表达式里的匿名函数。看似没有什么问题，但是在Qt 5.15上报错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /Users/runner/work/FlowD/FlowD/src/SettingsBasicWidget.cpp:21:5: error: no matching member function for call to \u0026#39;connect\u0026#39; connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { ^~~~~~~ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:222:36: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const char *\u0026#39; for 2nd argument static QMetaObject::Connection connect(const QObject *sender, const char *signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:225:36: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const QMetaMethod\u0026#39; for 2nd argument static QMetaObject::Connection connect(const QObject *sender, const QMetaMethod \u0026amp;signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:481:41: note: candidate function not viable: no overload of \u0026#39;currentIndexChanged\u0026#39; matching \u0026#39;const char *\u0026#39; for 2nd argument inline QMetaObject::Connection QObject::connect(const QObject *asender, const char *asignal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:242:43: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; static inline QMetaObject::Connection connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:283:13: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:322:13: note: candidate template ignored: couldn\u0026#39;t infer template argument \u0026#39;Func1\u0026#39; connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, const QObject *context, Func2 slot, ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:274:13: note: candidate function template not viable: requires 3 arguments, but 4 were provided connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, Func2 slot) ^ /Users/runner/work/FlowD/Qt/5.15.2/clang_64/lib/QtCore.framework/Headers/qobject.h:314:13: note: candidate function template not viable: requires 3 arguments, but 4 were provided connect(const typename QtPrivate::FunctionPointer\u0026lt;Func1\u0026gt;::Object *sender, Func1 signal, Func2 slot) ^ 1 error generated. 为什么会出现这种情况呢？ 因为QComboBox 有两个重载的信号，原型分别是void\tcurrentTextChanged(const QString \u0026amp;text)和void\tcurrentIndexChanged(int index)，上面的代码我们明显是想要连接void\tcurrentIndexChanged(int index)这个信号，但是编译器当成了void\tcurrentTextChanged(const QString \u0026amp;text)这个信号，所以会报出参数不匹配的错误:matching member function for call to 'connect' connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) 。 上面的代码在Qt 6上不会报错。\n我们该如何解决呢？只需使用预定义宏，将比Qt 6.0.0版本低的部分的代码改成QOverload\u0026lt;int\u0026gt;::of(\u0026amp;QComboBox::currentIndexChanged)即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #if QT_VERSION \u0026lt;= QT_VERSION_CHECK(6, 0, 0) connect(ui-\u0026gt;styleComboBox, QOverload\u0026lt;int\u0026gt;::of(\u0026amp;QComboBox::currentIndexChanged), this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); #else connect(ui-\u0026gt;styleComboBox, \u0026amp;QComboBox::currentIndexChanged, this, [this](int index) { //TODO: change theme spdlog::info(\u0026#34;User change default theme to {}\u0026#34;, index); AppConfig::instance().setBasic(\u0026#34;style\u0026#34;, index); }); #endif ","date":"2024-09-16T00:00:00Z","image":"https://programcx.github.io/p/qt-5.15-connect-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9D%91/qt_hu6cd4f64cbe970e806893d3bd1f4a2f5a_17484_120x120_fill_q75_h2_box_smart1_2.webp","permalink":"https://programcx.github.io/p/qt-5.15-connect-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A7%E5%9D%91/","title":"Qt 5.15 connect() 函数的一个大坑"},{"content":"Java中super关键字的理解 访问超类的成员函数和变量 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Main { public static void main(String[] args) { Manager manager = new Manager(); manager.setBonus(8000); System.out.println(manager.getSalary()); } } class Employee{ private int salary = 6000; public void setSalary(int salary){ this.salary=salary; } public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public void setBonus(int bonus){ this.bonus=bonus; } public int getBonus(){ return bonus; } //覆盖超类的函数 @Override public int getSalary(){ return bonus + this.salary; } } 这段代码声明了超类Employee，以及继承了这个超类的Manager类。定义了Manager类的manager对象，manager的奖金设置为8000元。最后打印出manager的总薪水。 但是，这段代码有一个很严重的错误。由于在超类Employee中，salary为private类型的，所以manager无法访问salary的值。为了遵循数据的隐蔽性原则，我们不能将它定义为public类型。不过，我们可以借助super关键字来达到目的。\n以下是修改过的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Main { public static void main(String[] args) { Manager manager = new Manager(); manager.setBonus(8000); System.out.println(manager.getSalary()); } } class Employee{ private int salary = 6000; public void setSalary(int salary){ this.salary = salary; } //获得salary的值 public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public void setBonus(int bonus){ this.bonus = bonus; } public int getBonus(){ return bonus; } @Override public int getSalary(){ return bonus + super.getSalary();\t//改为 super.getSalary } } 在这段代码中，增加了getSalary()函数，这个函数返回salary的值。由于可以使用关键字super访问超类的成员函数和变量，super.getSalary()就获得了Employee类的salary变量。\n调用父类的构造方法 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Main { public static void main(String[] args) { Manager manager = new Manager(8000); manager.setBonus(800); System.out.println(manager.getSalary()); } } class Employee{ public Employee(int salary){ this.salary = salary; } private int salary = 6000; public void setSalary(int salary){ this.salary = salary; } public int getSalary(){ return salary; } } class Manager extends Employee{ private int bonus = 0; public Manager(int salary) { super(salary);\t//调用超类的构造器 } public void setBonus(int bonus){ this.bonus = bonus; } public int getBonus(){ return bonus; } @Override public int getSalary(){ return bonus + super.getSalary(); } } manger无法访问超类的私有成员，但是可以通过超类的构造器来访问它们。\n注意：超类的构造器必须是子类的构造器里面的第一个语句！\n解决成员变量名或方法名冲突 举个例子：\n1 2 3 4 5 6 7 8 9 10 11 12 class Parent { int x = 10; } class Child extends Parent { int x = 20; void display() { System.out.println(\u0026#34;Child x = \u0026#34; + x); // 访问 Child 类的 x System.out.println(\u0026#34;Parent x = \u0026#34; + super.x); // 使用 super 访问 Parent 类的 x } } 当子类中的成员变量名或方法名与超类中的成员变量名或方法名相同时，子类中的方法或变量会隐藏超类中的方法或变量。此时，如果你想在子类中访问被隐藏的超类成员，就需要使用super 关键字。\n","date":"2024-09-09T00:00:00Z","image":"https://programcx.github.io/p/java%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%90%86%E8%A7%A3/","title":"Java中super关键字的理解"},{"content":"C++代码规范总结（部分） 下面内容总结（有的是直接复制概述，因为原文讲的比较严谨）于https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/\n头文件 #include的路径和顺序（每个类型之间要有空行） 配套的头文件 C语言系统文件 C++标准库头文件 其他库的头文件 本项目的头文件 要有#define防护符 避免向前声明 10行以下用内联函数 作用域 禁止使用using namespace ...; 大型项目要使用命名空间，以注释结尾 尽量将非成员函数放入命名空间，不要使用全局函数 最好初始化时声明 要在循环外声明类 尽量不要使用全局的静态变量、类，除非它们可以平凡地析构 构造函数中不得使用虚函数， 尽量不要使用隐式转换类型，单参数函数使用explicit关键字 int、double等类型建议使用传值、std::string等类型建议使用传引用，尽量不要传指针 基类最好是抽象类，且构造函数和析构函数必须声明为protected，最好不要继承具体类 只能用 struct 定义那些用于储存数据的被动对象. 其他情况应该使用 class 组合优于继承，使用public继承 谨慎使用重载运算符，除非与直觉相同；禁止使用自定义字面量 必须将所有数据成员声明为private 声明次序 public protected private 以下是每一个不同作用域的声明次序： 类型和类型别名 （仅适用于结构体），非静态数据成员 静态常量 工厂函数 构造函数和赋值运算符 析构函数 所有其他函数，包括静态和非静态函数，以及友元函数 其它数据成员，包括静态和非静态的 函数 行数超过40行在不影响程序逻辑的情况下要进行分割 只有在常规写法 (返回类型前置) 不便于书写或不便于阅读时使用返回类型后置语法 尽量不使用缺省函数参数，少数极端情况除外。尽可能改用函数重载 允许合理的使用友元类及友元函数 其它C++特性 尽量不使用 C++ 异常. 不要使用强制转换 除了写日志，尽量不要使用流 对于迭代器和其他模板对象使用前缀形式 (++i) 的自增, 自减运算符 任何可能的情况下都要使用 const 使用宏时要非常谨慎, 尽量以内联函数, 枚举和常量代替之 指针使用nullptr，字符使用'\\0'，而不是0字面量 尽可能用 sizeof(varname) 代替 sizeof(type) 使用auto绕过繁琐的类型名称，但要可读性好 可以用列表初始化 使用预处理宏时要非常谨慎，下面是要使用宏时需要遵守的规则： 不要在头文件中使用宏 在马上要使用时才进行 #define, 使用后要立即#undef 不要只是对已经存在的宏使用#undef，选择一个不会冲突的名称 不要试图使用展开后会导致 C++ 构造不稳定的宏, 不然也至少要附上文档说明其行为 不要用 ## 处理函数，类和变量的名字 适当使用lambda表达式，当lambda将转移当前作用域时，首选显式捕捉 不要使用复杂的模板编程 命名约定 函数命名, 变量命名, 文件命名要有描述性; 少用缩写 文件名全部要小写，可以包含“-”或“_” 类型名称首字母要大写，不能有下划线 变量命名要全部小写，单词之间使用下划线 常规函数使用大小写混合 命名空间要小写，不可以出现缩写 枚举的命名应当和常量或宏一致 通常不应该使用宏. 如果不得不用, 其命名像枚举命名一样全部大写, 使用下划线 注释 在每一个文件开头加入版权公告，包含法律、版权、作者信息。应当对文件的内容做一个大致的说明, 同时说明各概念之间的联系。 每个类的定义都要附带一份注释, 描述类的功能和用法, 除非它的功能相当明显 函数声明处的注释描述函数功能; 定义处的注释描述函数实现 每个类数据成员 (也叫实例变量或成员变量) 都应该用注释说明用途,如果变量可以接受 NULL 或 -1 等警戒值, 须加以说明 所有全局变量也要注释说明含义及用途, 以及作为全局变量的原因 对于代码中巧妙的, 晦涩的, 有趣的, 重要的地方加以注释 巧妙或复杂的代码段前要加注释 比较隐晦的地方要在行尾加入注释 永远不要 用自然语言翻译代码作为注释 对那些临时的, 短期的解决方案, 或已经够好但仍不完美的代码使用 TODO 注释，并加上自己身份标识 格式 每一行代码字符数不超过 80 尽量不使用非 ASCII 字符, 使用时必须使用 UTF-8 编码 只使用空格, 每次缩进 2 个空格 返回类型和函数名在同一行, 参数也尽量放在同一行, 如果放不下就对形参分行, 分行方式与 函数调用 一致 如果能增强可读性, 简短的条件语句允许写在同一行. 只有当语句简单并且没有使用 else 子句时使用 单行语句不需要使用大括号, 如果你喜欢用也没问题; 复杂的条件或循环语句用大括号可读性会更好. 也有一些项目要求 if 必须总是使用大括号 如果有不满足 case 条件的枚举值, switch 应该总是包含一个 default 匹配，如果 default 应该永远执行不到, 简单的加条 assert 在单语句循环里, 括号可用可不用 空循环体应使用 {} 或 continue, 而不是一个简单的分号 句点或箭头前后不要有空格. 指针/地址操作符 (*, \u0026amp;) 之后不能有空格 如果一个布尔表达式超过 标准行宽, 断行方式要统一一下 预处理指令不要缩进, 从行首开始 构造函数初始化列表放在同一行或按四格缩进并排多行 命名空间内容不缩进 两个函数定义之间的空行不要超过 2 行, 函数体首尾不要留空行, 函数体中也不要随意添加空行 规则特例 不要使用 #pragma once ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/c-/cpp_hu4f8d777476dd4c631cf6bb374e06af91_91138_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/c-/","title":"C++ 代码规范总结"},{"content":"该文章用来记录java学习过程中看似应该不会发生的异常\n我们有一个 Main.java 和 cn/pinsoftstd/Study.java，源代码如下：\nMain.java:\n1 2 3 4 5 6 7 8 9 10 11 12 import cn.pinsoftstd.study.Study; public class Main { public static void main(String[] args) { Study study=new Study(); study.printHelloWorld(); study.addProgramming(\u0026#34;XiaoMing\u0026#34;); study.addProgramming(\u0026#34;XiaoHong\u0026#34;); study.addProgramming(\u0026#34;LiJun\u0026#34;); study.removeProgramming(\u0026#34;LiJun\u0026#34;);\t//发生异常 study.printProgramingNames(); } } cn/pinsoftstd/Study.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 package cn.pinsoftstd.study; import java.util.ArrayList; import java.util.Iterator; /** * The class study provides an interface for developers to add and remove * the ones who are studying programming or not. * @author Program * @version 1.0 */ public class Study { public Study(){ } /** This prints \u0026#34;Hello World\u0026#34;,which is the person who must print once * study a programming language. * @author Program */ public void printHelloWorld(){ System.out.println(\u0026#34;Hello World\u0026#34;); } /** * This method adds a person to the Study Programming category. */ public Programming addProgramming(String name){ Programming pr=new Programming(name); programmings.add(pr); return pr; } /** * This method removes a person from the Study Programming category. */ public boolean removeProgramming(String name) { boolean removed = false; for (Programming pr : programmings) { if (pr.name.equals(name)) { programmings.remove(pr);\t//发生异常 removed = true; } } return removed; } /** * This method prints the names of people who are studying programming. */ public void printProgramingNames(){ for(Programming pr:programmings){ System.out.println(pr.name); } } private ArrayList\u0026lt;Programming\u0026gt; programmings=new ArrayList\u0026lt;\u0026gt;(); public class Programming{ private String name; public Programming(String name){ this.name=name; } public String name(){ return this.name; } public void printStudyingProgramming(){ System.out.println(\u0026#34;Study Programming:\u0026#34;+name); } } } 自己写的时候感觉没有问题，结果运行的时候抛出了 java.ConcurrentModificationException 异常。异常代码为Main.java中的 study.printProgramingNames();，Study.java中的programmings.remove(pr);。 其实，是因为在 Java 中增强型for循环使用了迭代器(iterator)遍历，如果在遍历的时候使用了 study.printProgramingNames();，迭代器会检测到数组列表的变化，从而抛出java.util.ConcurrentModificationException 异常。\n解决方法 方法一：使用迭代器遍历programmings数组列表，不使用增强型for循环遍历。下面是修改后的代码： 1 2 3 4 5 6 7 8 9 10 11 12 public boolean removeProgramming(String name) { boolean removed=false; Iterator\u0026lt;Programming\u0026gt;it=programmings.iterator(); while (it.hasNext()){\t//使用迭代器遍历 Programming pr=it.next(); if(pr.name.equals(name)){ it.remove(); removed=true; } } return removed; } 方法二：通过遍历索引(index)来遍历数组列表programmings。下面是修改后的代码:\n1 2 3 4 5 6 7 8 9 10 public boolean removeProgramming(String name) { boolean removed = false; for(int i=0;i\u0026lt;programmings.size();i++){ if(programmings.get(i).name.equals(name)){ programmings.remove(i); removed = true; } } return removed; } ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/java/java_hu2582121eb752963b1ceb7fad85fc990d_36519_120x120_fill_q75_box_smart1.jpg","permalink":"https://programcx.github.io/p/java/","title":"Java 一种 java.util.ConcurrentModificationException 异常原因"},{"content":"这个博客用来回忆这道题目，本人算法新手\n题目： 在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。\n返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n示例 1： 输入：grid = [[2,1,1],[1,1,0],[0,1,1]] 输出：4\n示例 2： 输入：grid = [[2,1,1],[0,1,1],[1,0,1]] 输出：-1 解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。\n示例 3： 输入：grid = [[0,2]] 输出：0 解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n提示：\nm == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 10 grid[i][j] 仅为 0、1 或 2 解题思路 先遍历所有的网格，统计新鲜橘子的个数，并把腐烂的橘子添加到队列。 使用广度优先搜索（BFS），不断感染四周的橘子，将已经感染过其他橘子的烂橘子从队列中弹出（便于统计还有哪些橘子没有感染其他好橘子）。每感染一个橘子，将新鲜橘子个数减去一。每感染一轮，时间加一。 最后检测新鲜的橘子个数是否为零，如果为零，则返回总共花去的分钟数；如果新鲜的橘子个数不为零，说明还有橘子永远不会被感染，根据题目要求，返回-1。 解题代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public: int orangesRotting(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size();\t//记录每一行的橘子个数 if (m == 0) return -1; //如果没有橘子，直接返回-1 int n = grid[0].size(); //记录每一列橘子个数 if (n == 0) return -1; queue\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; q; int fresh = 0; //遍历所有网格 for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == 1) {\t//如果为新鲜橘子 fresh++;\t//新鲜橘子个数就加一 } if (grid[i][j] == 2) { //如果橘子不是新鲜的 q.emplace(i, j);\t//就把烂橘子放入队列 } } } //开始广度优先搜索（BFS） int minutes = 0; vector\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; dirs = { {1,0},{-1,0},{0,1},{0,-1} }; //定义四个方向 while (!q.empty() \u0026amp;\u0026amp; fresh \u0026gt; 0) {\t//如果队列q不为空且有新鲜橘子 int size = q.size();\t//记录才开始或几轮下来还有多少未感染其他橘子的烂橘子 for (int k = 0; k \u0026lt; size; ++k) {\t//对这些橘子进行遍历 auto [i, j] = q.front(); //获取队列中第一个未感染其它橘子的烂橘子 q.pop();\t//将该橘子弹出 for (const auto\u0026amp; [x, y] : dirs) {\t//遍历四个方向 int dx = i + x, dy = j + y;\t//计算烂橘子四周的坐标值 if (dx \u0026gt;= 0 \u0026amp;\u0026amp; dx \u0026lt; m \u0026amp;\u0026amp; dy \u0026gt;= 0 \u0026amp;\u0026amp; dy \u0026lt; n \u0026amp;\u0026amp; grid[dx][dy] == 1) {\t//如果在矩阵范围内且该橘子是好橘子（避免重复感染和越界问题） grid[dx][dy] = 2;\t//就感染这个橘子 q.emplace(dx, dy); //将这个橘子添加到未感染其它橘子的烂橘子的队列 fresh--;\t//好橘子数量就减一 } } } ++minutes; //计算时间 } return fresh == 0 ? minutes : -1; } }; 提交结果 ","date":"2024-09-05T00:00:00Z","image":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/question_hu80ece0439f120d211a32693abd2dfdea_42586_120x120_fill_box_smart1_3.png","permalink":"https://programcx.github.io/p/leetcode-%E7%AC%AC994%E9%A2%98-%E8%85%90%E7%83%82%E7%9A%84%E6%A9%98%E5%AD%90/","title":"LeetCode 第994题 腐烂的橘子"},{"content":"记录学习\n填涂颜色 题目描述 由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：\n如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ 在闭合圈内。闭合圈不一定是环形的，可以是任意形状，但保证闭合圈内的 $0$ 是连通的（两两之间可以相互到达）。\n1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 1 0 1 1 1 1 1 1 1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 0 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 1 2 1 1 1 1 1 1 1 输入格式 每组测试数据第一行一个整数 $n(1 \\le n \\le 30)$。\n接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \\times n$ 的方阵。\n方阵内只有一个闭合圈，圈内至少有一个 $0$。\n输出格式 已经填好数字 $2$ 的完整方阵。\n样例 #1 样例输入 #1 1 2 3 4 5 6 7 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 0 0 1 1 1 0 0 0 1 1 0 0 0 0 1 1 1 1 1 1 1 样例输出 #1 1 2 3 4 5 6 0 0 0 0 0 0 0 0 1 1 1 1 0 1 1 2 2 1 1 1 2 2 2 1 1 2 2 2 2 1 1 1 1 1 1 1 提示 对于 $100%$ 的数据，$1 \\le n \\le 30$。\n思路 1.输入矩阵 2.进行BFS搜索，标记搜索过的 3.输出，如果值为零且未被标记，则一定是被包围的，就输出2\n代码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; using namespace std; struct point { int x = 0; int y = 0; }; queue\u0026lt;point\u0026gt; q; int dx[4] = { -1,1,0,0 }, dy[4] = { 0,0,-1,1 }; int land[35][35] = {0}, mark[35][35] = {0}, n, tmp; int main() { cin \u0026gt;\u0026gt; n; //输入 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { cin \u0026gt;\u0026gt; tmp; if (tmp == 1) { land[i][j] = tmp; } } } //把起始点标记为经过 mark[0][0] = 1; q.push(point{0,0}); //开始bfs搜索 while (!q.empty())\t//一直到搜索完成 { point p = q.front();\t//取出搜索队列的第一个元素 q.pop();\t//弹出第一个元素 //前后左右 for (int i = 0; i \u0026lt; 4; i++) { int x = dx[i] + p.x; int y = dy[i] + p.y; //如果越界，就跳出此次循环 if (x \u0026lt; 0 || x \u0026gt; n || y \u0026lt; 0 || y \u0026gt; n ) continue; //如果未被搜索且数值为零 if (land[x][y] == 0 \u0026amp;\u0026amp; mark[x][y] == 0) { mark[x][y] = 1;\t//标记为已经搜索 q.push(point{ x,y });\t//加入搜索队列 } } } cout \u0026lt;\u0026lt; endl; //遍历矩阵 for (int i = 0; i \u0026lt; n; i++) { for (int j = 0; j \u0026lt; n; j++) { //如果没被搜索过 if (land[i][j] == 0 \u0026amp;\u0026amp; mark[i][j] == 0) { cout \u0026lt;\u0026lt; 2 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//说明被包围，则输出2 } else if (land[i][j] == 1) { cout \u0026lt;\u0026lt; 1 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//1就是边界 } else { cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; \u0026#34; \u0026#34;;\t//否则就是搜过的0 } } cout \u0026lt;\u0026lt; endl; } return 0; } ","date":"2024-09-05T00:00:00Z","permalink":"https://programcx.github.io/p/%E6%B4%9B%E8%B0%B7-p1162-%E5%A1%AB%E6%B6%82%E9%A2%9C%E8%89%B2-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/","title":"洛谷 P1162 填涂颜色 广度优先搜索"}]